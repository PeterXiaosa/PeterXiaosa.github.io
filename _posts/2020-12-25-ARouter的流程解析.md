---
layout: post
title: 组件化之ARouter的流程解析
categories: [Android]
description: 介绍常见的组件化库——ARouter。
keywords: Android，View的绘制
---


# 组件化之ARouter的原理解析

## 1. 为什么使用组件化
        随着项目的越来越大，业务逻辑也越来越复杂。如果我们只有一个 app 模块，各种各样的功能通过分包来区别的话，即时包分的再好，随着功能的增多也会使我们的 app 模块变得越来越臃肿，同时不利于多人同时开发。鉴于此，组件化便慢慢的开始浮出水面。

        组件化可以帮我们根据功能区分多个不同的模块，多人同时开发自己的模块，每个模块之间相互编译。而 app 主module 可以导入不同的功能模块实现对应功能，同时不会产生版本管理冲突。这种方法同样可以作为 SDK 的方式，将功能包开放给其他人或项目进行接入，节省开发时间和人力。

        上述，提到了为什么使用组件化的原因。那么在使用中就会发现出现一个问题，每个模块之间如何进行通信呢？例如 A module 的 Activity A 如何和 B module 中的 Activity B进行相互跳转呢？

        首先，在 A 和 B 中通过 startActivity(new Intent(A.this, B.class)) 肯定是不行的，因为 module A 和 B 无法相互依赖，所以无法同时在 A， B module中找到对方 Activity 的类。通过显示跳转不行，那么我们可以尝试通过隐形跳转来实现。是的，通过隐式跳转可以做到相互跳转，但是需要提前在 AndroidManifest 中定义好 Intent-filter， 这样跳转很不方便，因为要跳转之前需要先查一下该 Activity 的过滤类型。 那除了这种方法我们还有其他方法嘛？ 好像是有的，同样，我们可以通过显示跳转来实现。但显示跳转中需要的 Activity 类，我们不通过一个 module 来依赖另外一个 module 来实现，而是可以通过反射来实现。我只需要知道我所要跳转类的路径，我就可以通过反射来获取到该 Activity 类，获取到了类我就可以直接通过 startActivity 来跳转了。

        其实在这，我们就已经摸到了一点组件化的门道了。但通过反射的话，我们还要记住每个 Activity 所对应的地址，这和隐式跳转一样要求太高了。那这时，我们可能会想到，是不是可以通过定义一种注解，然后每个Activity 都使用这种注解，通过注解中的不同参数来区分不同的Activity，只需要通过反射获取所有注解就能知道一个个 Activity 的类了。

        这其实就是组件化的最基础的模型了，但是ARouter 将它做的更好更优化，在编译期通过扫描注解来生成 .java 文件，在运行时倒入文件中的内容，完成对 Activity 类的存储。

        讲到这里，也是时候开始介绍 ARouter的工作流程了。
    
## 2. ARouter 工作流程

ARouter 工作流程我们可以根据 ARouter的使用来进行介绍。在我们使用 ARouter 的时候
